
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.47
 */


/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitxtm: 2.23.1.9
 */

#ifndef SOM_Module_filesys_Source
#define SOM_Module_filesys_Source
#endif
#define WPFileSystemFix_Class_Source
#define M_WPFileSystemFix_Class_Source

#define _RETAIL /* to completely eliminate the ...MethodDebug(...) debugging output to SOMOutCharRoutine (default:stdout) */
#include "filesys.xih"
#include "system.xih"
#include "except.h"

HMODULE g_hModule = NULLHANDLE;


/*
  IMPORTANT NOTE ON CALLING _CRT_init and _CRT_term in any case, no matter if you link to the CRT statically or dynamically

<quote>
#: 172179 S4/IBM VisualAge C++
    31-Jan-96  02:11:56
Sb: #Destructors at exit(int)
Fm: ROGER PETT [IBM] 73251,1733
To: Dean Roddey 72170,1614 (X)

OS/2 is supposed to run DLL termination in the opposite order to the DLL
initialization.  Since static object destructors and CRT termination are
done in the DLL termination ocde, it is a problem if this does not happen.

Unfortunately, there *are* conditions where the DLL termination can run
"out of order".  It's a known OS/2 bug, and I understand that it is not
fixable without some rather major surgery (i.e. it's likely to introduce new
bugs!).
Personally, I'd rather have the devil I know, since you can program your
way around it.  For example:
  In VAC++, the CRT exposes both _CRT_init() and _CRT_term(), and you
should call both, regardless of whether you statically or dynamically bind to
the runtime.   This is a change from C Set++.  We count the number of times
the runtime is initialized, and only completely shut down the runtime when
the number of _CRT_term() calls match the number of _CRT_init() calls.  This
insures the runtime stays "alive" until all its users have terminated.  We get
away with this because the OS doesn't immediately unload the DLL after
running the DLL termination.

Roger..
</quote>
*/

/*
   there are other ways to query the module handle
   but this one seems simple enough
   we need the module handle in wpModifyMenu
   so that we can load our menu via wpInsertPopupMenuItems
*/
ULONG APIENTRY _DLL_InitTerm(ULONG modhandle,ULONG flag)
{
    if(flag == 0)
    {
        if (_CRT_init())
        {
            return 0; /* fail */
        }
#ifdef __cplusplus
        __ctordtorInit();
#endif
        g_hModule   = modhandle;
        return 1;
    }
    else if (flag == 1)
    {
#ifdef __cplusplus
        __ctordtorTerm();
#endif

        _CRT_term();

        return 1; /* success */
    }
    else
    {
        return 0;
    }
}


/*
   introductory note: because this class is a REPLACEMENT class
   the 2 metaclass methods wpclsQueryStyle and wpclsQueryTitle have NOT
   been overridden
   wpclsQueryStyle is most often used to prevent a class from creating a
   template in the template folder+removing capability to mark an existing
   object as being a template, wpclsQueryTitle is used to give a default
   title when a new object is created from either a template or from the
   context menu.
   It is not advisable to modify the behaviour of the parent class as the user
   does not expect a default object name to change only because some
   class enhancement is active
   changing the object style is also a bad idea as the REPLACEMENT class
   will replace the original class and therefore the original default object style
   is no longer available if it is changed by the replacement class, additionally
   the already existing templates of the original class conflict with the new
   setting (if the replacement class sets the default object style to "no template")
*/



SOM_Scope void SOMLINK somDefaultInit(WPFileSystemFix *somSelf, 
                                      som3InitCtrl* ctrl)
{
    WPFileSystemFixData *somThis; /* set in BeginInitializer */
    somInitCtrl globalCtrl;
    somBooleanVector myMask;
    WPFileSystemFixMethodDebug("WPFileSystemFix","somDefaultInit");
    WPFileSystemFix_BeginInitializer_somDefaultInit;

    WPFileSystemFix_Init_WPFileSystem_somDefaultInit(somSelf, ctrl);

    /*
     * local WPFileSystemFix initialization code added by programmer
     */
}


SOM_Scope void SOMLINK somDestruct(WPFileSystemFix *somSelf, 
                                   octet doFree, som3DestructCtrl* ctrl)
{
    WPFileSystemFixData *somThis; /* set in BeginDestructor */
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    WPFileSystemFixMethodDebug("WPFileSystemFix","somDestruct");
    WPFileSystemFix_BeginDestructor;

    /*
     * local WPFileSystemFix deinitialization code added by programmer
     */

    WPFileSystemFix_EndDestructor;
}


SOM_Scope BOOL  SOMLINK wpModifyMenu(WPFileSystemFix *somSelf, 
                                     HWND hwndMenu, HWND hwndCnr, 
                                     ULONG iPosition, ULONG ulMenuType, 
                                     ULONG ulView, ULONG ulReserved)
{
    BOOL fret;
    ULONG menuId;
    /* WPFileSystemFixData *somThis = WPFileSystemFixGetData(somSelf); */
    WPFileSystemFixMethodDebug("WPFileSystemFix","wpModifyMenu");

    fret = (WPFileSystemFix_parent_WPFileSystem_wpModifyMenu(somSelf, 
                                                             hwndMenu, 
                                                             hwndCnr, 
                                                             iPosition, 
                                                             ulMenuType, 
                                                             ulView, 
                                                             ulReserved));

    if (fret && (ulMenuType == MENU_OBJECTPOPUP)) {
        if (somSelf->somIsA(_WPFolder)) {
           menuId = ID_FOLDERMENU;
        } else {
           menuId = ID_FILEMENU;
        }
        somSelf->wpInsertMenuItems( hwndMenu,
                                             (ULONG)MIT_END,
                                             g_hModule,
                                             menuId,
                                             WPMENUID_PRIMARY);
    } /* endif */

    return fret;
}

SOM_Scope BOOL  SOMLINK wpMenuItemSelected(WPFileSystemFix *somSelf, 
                                           HWND hwndFrame, ULONG ulMenuId)
{
#define NUM_OBJECTS 100

    BOOL fret,rc;
    PSZ  pszName;
    CLASS  Classes[]={_WPFileSystem,NULL};
    WPFileSystem *Objects[NUM_OBJECTS];
    ULONG  errorid = 0UL;
    HFIND hFind = NULLHANDLE;
    ULONG ulCount = 0UL;
    ULONG i = 0UL;

    UCHAR pszBuffer[CCHMAXPATH];
    ULONG ulLen;
    WPFolder *theFolder;

    /* WPFileSystemFixData *somThis = WPFileSystemFixGetData(somSelf); */
    WPFileSystemFixMethodDebug("WPFileSystemFix","wpMenuItemSelected");

    switch(ulMenuId)
    {
        case MENUID_FOLDERSINGLE:
           /* for filesystem objects
              (all descendents of WPFileSystem like WPFolder and WPDataFile)
              resetting the title will also
              rewrite the filename
           */
           theFolder = (WPFolder *)somSelf;
           pszName = theFolder->wpQueryTitle();
           fret    = theFolder->wpSetTitleAndRenameFile(pszName,0UL);

           /*
              as a safety measure, make sure
              that all filesystem updates are
              flushed to the WPS so that all
              changes to the filesystem will
              be correctly reflected in any
              open view
           */
           theFolder->wpFlushNotifications();
           break;

        case MENUID_FOLDERMULTIPLE:
           theFolder = (WPFolder *)somSelf;
           fret    = TRUE;
           pszName = theFolder->wpQueryTitle();
           if (!theFolder->wpSetTitleAndRenameFile(pszName,0UL))
           {
              fret = FALSE;
              goto end2;
           }

           _WPFileSystemFix->wpclsSetError(0);
           ulCount = NUM_OBJECTS;
           rc = _WPFileSystemFix->wpclsFindObjectFirst(Classes,&hFind,NULL,theFolder,TRUE,NULL,(POBJECT)Objects,&ulCount);
           errorid = _WPFileSystemFix->wpclsQueryError();
           if ((!rc && (errorid == WPERR_BUFFER_OVERFLOW)) || rc) {
              for (i=0,rc = TRUE;i<ulCount;i++) {
                   pszName = Objects[i]->wpQueryTitle();
                   rc = rc && Objects[i]->wpSetTitleAndRenameFile(pszName,0UL);
                   Objects[i]->wpUnlockObject();
              } /* endfor */
              if (!rc) {
                 fret = FALSE;
                 goto end;
              } /* endif */
           } else {
              fret = FALSE;
              goto end;
           } /* endif */
           do {
              _WPFileSystemFix->wpclsSetError(0);
              ulCount = NUM_OBJECTS;
              rc = _WPFileSystemFix->wpclsFindObjectNext(hFind,(POBJECT)Objects,&ulCount);
              errorid = _WPFileSystemFix->wpclsQueryError();
              if ((!rc && (errorid == WPERR_BUFFER_OVERFLOW)) || rc) {
                 for (i=0,rc=TRUE;i<ulCount;i++) {
                      pszName = Objects[i]->wpQueryTitle();
                      rc = rc && Objects[i]->wpSetTitleAndRenameFile(pszName,0UL);
                      Objects[i]->wpUnlockObject();
                 } /* endfor */
                 if (!rc) {
                    fret = FALSE;
                    goto end;
                 } /* endif */
              } else {
                 fret = FALSE;
                 break;
              } /* endif */
           } while (errorid == WPERR_BUFFER_OVERFLOW); /* enddo */
           fret = TRUE;
end:
           _WPFileSystemFix->wpclsSetError(0);
           _WPFileSystemFix->wpclsFindObjectEnd(hFind);
end2:
           /*
              as a safety measure, make sure
              that all filesystem updates are
              flushed to the WPS so that all
              changes to the filesystem will
              be correctly reflected in any
              open view
           */
           theFolder->wpFlushNotifications();
           break;

        case MENUID_FILESINGLE:
           pszName = somSelf->wpQueryTitle();
           fret = somSelf->wpSetTitleAndRenameFile(pszName,0UL);
           break;

        default:
           fret =  (WPFileSystemFix_parent_WPFileSystem_wpMenuItemSelected(somSelf,
                                                                           hwndFrame,
                                                                           ulMenuId));
           break;
    }
    return fret;
}


SOM_Scope void  SOMLINK wpInitData(WPFileSystemFix *somSelf)
{
    /* WPFileSystemFixData *somThis = WPFileSystemFixGetData(somSelf); */
    WPFileSystemFixMethodDebug("WPFileSystemFix","wpInitData");

    CARDINAL32 ret;
    Volume_Control_Array arr;
    Volume_Information_Record rec;
    ULONG i;
#pragma pack(1)
    struct {
       UCHAR Command;
       UCHAR Unit;
    } CmdParm;
#pragma pack()
    ULONG ulPLen = sizeof(CmdParm);
    ULONG ulDLen = 0UL;
    APIRET rc = NO_ERROR;
    UCHAR chr;
    BOOL  fEject = FALSE;

    /* do our one time initialization here */
    if (somSelf->_get_fIsInitialized() == FALSE) {
      somSelf->_set_fIsInitialized(TRUE);

       _WPSystemFix->wpclsQuerySetting("EjectRemovables",&fEject,sizeof(fEject));
       if (fEject) {
          Open_LVM_Engine(TRUE,&ret);
          if (ret == LVM_ENGINE_NO_ERROR) {
             Refresh_LVM_Engine(&ret);
             arr = Get_Volume_Control_Data(&ret);
             if ((ret == LVM_ENGINE_NO_ERROR) && arr.Volume_Control_Data) {
                for (i=0;i<arr.Count;i++) {
                   if (arr.Volume_Control_Data[i].Device_Type == LVM_PRM) {
                      rec = Get_Volume_Information(arr.Volume_Control_Data[i].Volume_Handle,&ret);
                      chr = (UCHAR)toupper((int)rec.Current_Drive_Letter);

                      CmdParm.Command = 0;        /* unlock media */
                      CmdParm.Unit    = chr - 'A';
                      ulPLen = sizeof(CmdParm);
                      ulDLen = 0UL;
                      rc = DosDevIOCtl(-1,IOCTL_DISK,DSK_UNLOCKEJECTMEDIA,&CmdParm,ulPLen,&ulPLen,NULL,ulDLen,&ulDLen);

                      CmdParm.Command = 2;        /* eject media */
                      CmdParm.Unit    = chr - 'A';
                      ulPLen = sizeof(CmdParm);
                      ulDLen = 0UL;

                      /*
                         for one reason or the other, the following IOCTL tends to trap
                         I don't know why but we better catch the exception so that the WPS won't crash
                      */
                      TRY(exc) {
                         rc = DosDevIOCtl(-1,IOCTL_DISK,DSK_UNLOCKEJECTMEDIA,&CmdParm,ulPLen,&ulPLen,NULL,ulDLen,&ulDLen);
                      }
                      ENDTRY(exc);
                   } /* endif */
                } /* endfor */
                Free_Engine_Memory(arr.Volume_Control_Data);
             } /* endif */
             Close_LVM_Engine();
          } /* endif */
       } /* endif */

    } /* endif */

    WPFileSystemFix_parent_WPFileSystem_wpInitData(somSelf);
}

/*
   we need to take the route and define a staticdata variable
   as this is the ONLY way to get a variable that only exists
   exactly ONCE in the whole system and is not inherited by
   child classes.
   Since this variable is defined in a CLASS and not a METACLASS,
   we can therefore only use it in a class method and not a metaclass method.
   That's why we eventually override wpInitData and make use
   of one time initialization in that method.
*/

static BOOL fInit = FALSE;
/* Programmer Provided Class Initialization called by SOM kernel */
void SOMLINK InitOnce(SOMClass *cls)
{
   /* see the SOM Programming Guide on how to deal with a staticdata variable */
   /* also the "classInit" modifier needs to be used to define this procedure */
   /* and the static variable has to be created as an attribute of the class */
   /* see the IDL file */
   WPFileSystemFixClassData.fIsInitialized = &fInit;
}

SOM_Scope void  SOMLINK wpclsInitData(M_WPFileSystemFix *somSelf)
{
    /* M_WPFileSystemFixData *somThis = M_WPFileSystemFixGetData(somSelf); */
    M_WPFileSystemFixMethodDebug("M_WPFileSystemFix","wpclsInitData");

    M_WPFileSystemFix_parent_M_WPFileSystem_wpclsInitData(somSelf);

    /* we have to load WPSystemFix class because we are making use of the Metaclass object _WPSystemFix */
    WPSystemFixNewClass(WPSystemFix_MajorVersion,WPSystemFix_MinorVersion);
}

SOM_Scope void  SOMLINK wpclsUnInitData(M_WPFileSystemFix *somSelf)
{
    /* M_WPFileSystemFixData *somThis = M_WPFileSystemFixGetData(somSelf); */
    M_WPFileSystemFixMethodDebug("M_WPFileSystemFix","wpclsUnInitData");

    M_WPFileSystemFix_parent_M_WPFileSystem_wpclsUnInitData(somSelf);
}

